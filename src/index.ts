import path from "node:path";
import { cwd } from "node:process";
import merge from "lodash.merge";
import type { PluginOption, ResolvedConfig, UserConfig } from "vite";
import { createLogger } from "./logger";
import type { PluginOptions } from "./types";
import { resolveServerUrl } from "./utils";
import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import copy from "esbuild-plugin-copy";
import { PLUGIN_NAME } from "./constants";
import fs from "node:fs";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY VITE-PLUGIN-OBSIDIAN
if you want to view the source, please visit the github repository of this plugin
*/
`;

export * from "./types";

const isDev = process.env.NODE_ENV === "development";
const logger = createLogger();

function preMergeOptions(options?: PluginOptions): PluginOptions {
  const opts: PluginOptions = merge(
    {
      banner: {
        js: banner,
      },
      entryPoints: ["plugin/main.ts"],
      bundle: true,
      external: [
        "obsidian",
        "electron",
        "@codemirror/autocomplete",
        "@codemirror/collab",
        "@codemirror/commands",
        "@codemirror/language",
        "@codemirror/lint",
        "@codemirror/search",
        "@codemirror/state",
        "@codemirror/view",
        "@lezer/common",
        "@lezer/highlight",
        "@lezer/lr",
        ...builtins,
      ],
      target: "es2022",
      logLevel: "info",
      sourcemap: isDev ? "inline" : undefined,
      treeShaking: true,
      resolveExtensions: [".svelte", ".svelte.ts", ".ts", ".js"],
      tsconfig: path.resolve(process.cwd(), "tsconfig.json"),
    } satisfies PluginOptions,
    options,
  );

  const opt = opts || {};

  if (isDev) {
    opt.sourcemap = opt.sourcemap ?? true;
  } else {
    opt.minify ??= true;
  }

  opt.format = "cjs";

  return opts;
}

export function useObsidianPlugin(options?: PluginOptions): PluginOption[] {
  const opts = preMergeOptions(options);

  const handleConfig = (config: UserConfig): UserConfig => {
    let outDir = config?.build?.outDir || "dist";
    opts.outdir = outDir;

    const cors = {
      origin: ["app://obsidian.md"],
      credentials: true,
    };
    const port = config?.server?.port || 15173;
    const strictPort = true;

    return {
      server: {
        cors,
        port,
        strictPort,
      },
      build: {
        outDir,
        sourcemap: isDev ? true : config?.build?.sourcemap,
      },
    };
  };

  let resolvedConfig: ResolvedConfig;

  return [
    {
      name: PLUGIN_NAME,
      apply: "serve",
      config(config) {
        return handleConfig(config);
      },
      configResolved(config) {
        resolvedConfig = config;
      },
      configureServer(server) {
        if (!server || !server.httpServer) {
          return;
        }
        server.httpServer?.once("listening", async () => {
          logger.info("extension build start");

          const { onSuccess: _onSuccess, ...esbuildOptions } = opts || {};
          const context = await esbuild.context(
            merge(esbuildOptions, {
              plugins: [
                ...(esbuildOptions.plugins || []),
                copy({
                  assets: {
                    from: ["manifest.json"],
                    to: ["manifest.json"],
                  },
                }),
                // Custom plugin to modify manifest.json in development mode
                isDev && {
                  name: "modify-manifest-dev",
                  setup(build) {
                    build.onEnd(async () => {
                      try {
                        const outdir = opts.outdir || "dist";
                        const manifestPath = path.join(outdir, "manifest.json");
                        if (fs.existsSync(manifestPath)) {
                          const content = fs.readFileSync(manifestPath, "utf8");
                          const manifest = JSON.parse(content);
                          manifest.id = `${manifest.id}-dev`;
                          manifest.name = `${manifest.name} (Dev)`;
                          fs.writeFileSync(
                            manifestPath,
                            JSON.stringify(manifest, null, 2),
                          );
                          logger.info(`Modified manifest.json with dev suffix`);
                        }
                      } catch (error) {
                        logger.error(`Error modifying manifest.json: ${error}`);
                      }
                    });
                  },
                },
              ],
              define: {
                "window.__DEV__": JSON.stringify({
                  serverUrl: resolveServerUrl(server),
                }),
              },
            }),
          );

          await context.watch();
        });
      },
    } satisfies PluginOption,
    {
      name: PLUGIN_NAME,
      apply: "build",
      enforce: "post",
      config(config) {
        return handleConfig(config);
      },
      configResolved(config) {
        resolvedConfig = config;
      },
      async closeBundle() {
        let outDir = resolvedConfig.build.outDir
          .replace(cwd(), "")
          .replaceAll("\\", "/");
        if (outDir.startsWith("/")) {
          outDir = outDir.substring(1);
        }

        const { onSuccess: _onSuccess, ...esbuildOptions } = opts || {};

        await esbuild.build(
          merge(esbuildOptions, {
            minify: false, // https://github.com/EMH333/esbuild-svelte/issues/272
            plugins: [
              ...(esbuildOptions.plugins || []),
              copy({
                assets: {
                  from: ["manifest.json"],
                  to: ["manifest.json"],
                },
              }),
            ],
          }),
        );

        if (typeof _onSuccess === "function") {
          await _onSuccess();
        }

        logger.info("extension build success");
      },
    } satisfies PluginOption,
  ];
}

export default useObsidianPlugin;
